<!DOCTYPE html>
<html>
<head>
  <meta charset="UTF-8">
  <title>Handoff Viewer</title>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.css">
  <style>
    body { margin: 0; background: #1e1e1e; height: 100vh; display: flex; flex-direction: column; align-items: center; }
    #controls { padding: 10px; }
    #controls button, #controls input { margin: 0 5px; padding: 8px 16px; font-size: 14px; }
    #terminal { width: 90%; flex: 1; margin-bottom: 28px; }
    #status-bar {
      position: fixed;
      bottom: 0;
      left: 0;
      right: 0;
      background: #252526;
      color: #9d9d9d;
      font-family: 'Consolas', 'Monaco', 'Courier New', monospace;
      font-size: 11px;
      padding: 4px 12px;
      display: flex;
      gap: 16px;
      border-top: 1px solid #3c3c3c;
      z-index: 100;
    }
    #status-bar .stat { display: flex; gap: 4px; }
    #status-bar .label { color: #6d6d6d; }
    #status-bar .value { color: #4ec9b0; }
  </style>
</head>
<body>
  <div id="controls">
    <button onclick="send('y\r')">y</button>
    <button onclick="send('n\r')">n</button>
    <button onclick="send('t\r')">t</button>
    <button onclick="send('\x03')">Ctrl-C</button>
    <button onclick="send('\x1b')">Esc</button>
    <button onclick="send('\x1b[A')">↑</button>
    <button onclick="send('\x1b[B')">↓</button>
    <button onclick="send('\x1b[D')">←</button>
    <button onclick="send('\x1b[C')">→</button>
    <button onclick="send('\x7f')">⌫</button>
    <input type="text" id="custom" placeholder="custom input" onkeydown="if(event.key==='Enter'){sendLine(this.value);this.value='';}">
    <button onclick="sendLine(document.getElementById('custom').value); document.getElementById('custom').value='';">Send</button>
  </div>
  <div id="terminal"></div>
  <div id="status-bar">
    <div class="stat"><span class="label">In:</span><span class="value" id="s-in">-</span></div>
    <div class="stat"><span class="label">Out:</span><span class="value" id="s-out">-</span></div>
    <div class="stat"><span class="label">Frames:</span><span class="value" id="s-fps">-</span></div>
    <div class="stat"><span class="label">Ratio:</span><span class="value" id="s-ratio">-</span></div>
    <div class="stat"><span class="label">Avg:</span><span class="value" id="s-avg">-</span></div>
    <div class="stat"><span class="label">Total:</span><span class="value" id="s-total">-</span></div>
    <div class="stat"><span class="label">Codec:</span><span class="value" id="s-codec">...</span></div>
  </div>
  <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.js"></script>
  <script type="module">
    const params = new URLSearchParams(location.search);
    let sessionId = params.get('id');
    let token = sessionStorage.getItem('handoff_token');
    
    // Clean URL if token was in querystring (remove it for security)
    if (params.get('token')) {
      token = params.get('token');
      sessionStorage.setItem('handoff_token', token);
      // Remove token from URL without reload
      params.delete('token');
      const cleanUrl = location.pathname + (params.toString() ? '?' + params.toString() : '');
      history.replaceState(null, '', cleanUrl);
    }
    
    function showConnectForm(error = '') {
      document.body.innerHTML = `
        <div style="color:#fff;padding:20px;">
          <h2>Connect to Session</h2>
          ${error ? '<p style="color:#f66;">' + error + '</p>' : ''}
          <form id="connect-form">
            <input id="id" placeholder="Session ID" value="${sessionId || ''}" style="padding:8px;margin:5px;">
            <input id="tok" type="password" placeholder="Token" style="padding:8px;margin:5px;">
            <button style="padding:8px 16px;">Connect</button>
          </form>
        </div>`;
      document.getElementById('connect-form').onsubmit = (e) => {
        e.preventDefault();
        const id = document.getElementById('id').value;
        const tok = document.getElementById('tok').value;
        if (id && tok) {
          sessionStorage.setItem('handoff_token', tok);
          location.search = '?id=' + encodeURIComponent(id);
        }
      };
    }
    
    if (!sessionId || !token) {
      showConnectForm();
    } else {
      // === Compression Setup ===
      let compressionMode = 'zstd'; // Will be set by server: none, zstd, deflate, smaz
      let hasNativeZstd = false;
      let zstdWasm = null;

      // === SMAZ Codec (for small ASCII strings) ===
      const SMAZ_REVERSE = [
        " ", "the", "e", "t", "a", "of", "o", "and", "i", "n", "s", "e ", "r", " th", " t", "in",
        "he", "th", "h", "he ", "to", "\r\n", "l", "s ", "d", " a", "an", "er", "c", " o", "d ",
        "on", " of", "re", "of ", "t ", ", ", "is", "u", "at", "   ", "n ", "or", "which", "f",
        "m", "as", "it", "that", "\n", "was", "en", "  ", " w", "es", " an", " i", "\r", "f ",
        "g", "p", "nd", " s", "nd ", "ed ", "w", "ed", "http://", "for", "te", "ing", "y ", "The",
        " c", "ti", "r ", "his", "st", " in", "ar", "nt", ",", " to", "y", "ng", " h", "with",
        "le", "al", "to ", "b", "ou", "be", "were", " b", "se", "o ", "ent", "ha", "ng ", "their",
        "\"", "hi", "from", " f", "in ", "de", "ion", "me", "v", ".", "ve", "all", "re ", "ri",
        "ro", "is ", "co", "f t", "are", "ea", ". ", "her", " m", "er ", " p", "es ", "by", "they",
        "di", "ra", "ic", "not", "s, ", "d t", "at ", "ce", "la", "h ", "ne", "as ", "tio", "on ",
        "n t", "io", "we", " a ", "om", ", a", "s o", "ur", "li", "ll", "ch", "had", "this", "e t",
        "g ", "e\r\n", " wh", "ere", " co", "e o", "a ", "us", " d", "ss", "\n\r\n", "\r\n\r",
        "=\"", " be", " e", "s a", "ma", "one", "t t", "or ", "but", "el", "so", "l ", "e s", "s,",
        "no", "ter", " wa", "iv", "ho", "e a", " r", "hat", "s t", "ns", "ch ", "wh", "tr", "ut",
        "/", "have", "ly ", "ta", " ha", " on", "tha", "-", " l", "ati", "en ", "pe", " re", "there",
        "ass", "si", " fo", "wa", "ec", "our", "who", "its", "z", "fo", "rs", ">", "ot", "un", "<",
        "im", "th ", "nc", "ate", "><", "ver", "ad", " we", "ly", "ee", " n", "id", " cl", "ac",
        "il", "</", "rt", " wi", "div", "e, ", " it", "whi", " ma", "ge", "x", "e c", "men", ".com"
      ];

      const SMAZ_CODEBOOK = {};
      SMAZ_REVERSE.forEach((s, i) => SMAZ_CODEBOOK[s] = i);

      function smazCompress(input) {
        const str = new TextDecoder().decode(input);
        const output = [];
        let verbatim = [];
        let i = 0;

        function flushVerbatim() {
          if (verbatim.length === 0) return;
          if (verbatim.length > 1) {
            output.push(255, verbatim.length - 1);
          } else {
            output.push(254);
          }
          output.push(...verbatim);
          verbatim = [];
        }

        while (i < str.length) {
          let encoded = false;
          for (let j = Math.min(7, str.length - i); j > 0; j--) {
            const code = SMAZ_CODEBOOK[str.substring(i, i + j)];
            if (code !== undefined) {
              flushVerbatim();
              output.push(code);
              i += j;
              encoded = true;
              break;
            }
          }
          if (!encoded) {
            verbatim.push(str.charCodeAt(i));
            if (verbatim.length === 256) flushVerbatim();
            i++;
          }
        }
        flushVerbatim();
        return new Uint8Array(output);
      }

      function smazDecompress(input) {
        const output = [];
        let i = 0;
        while (i < input.length) {
          const code = input[i];
          if (code === 254) {
            output.push(input[i + 1]);
            i += 2;
          } else if (code === 255) {
            const len = input[i + 1] + 1;
            for (let j = 0; j < len; j++) output.push(input[i + 2 + j]);
            i += 2 + len;
          } else {
            const s = SMAZ_REVERSE[code];
            for (let j = 0; j < s.length; j++) output.push(s.charCodeAt(j));
            i++;
          }
        }
        return new Uint8Array(output);
      }

      // Detect native zstd support
      try {
        new CompressionStream('zstd');
        hasNativeZstd = true;
      } catch {}

      // Load WASM fallback for zstd if needed
      async function loadZstdWasm() {
        if (hasNativeZstd || zstdWasm) return;
        try {
          const mod = await import('/zstd-wasm.esm.js');
          await mod.init('/zstd.wasm');
          zstdWasm = mod;
        } catch (err) {
          console.error('Failed to load zstd-wasm:', err);
        }
      }

      // Raw zstd compress helper
      async function zstdCompressRaw(data) {
        if (hasNativeZstd) {
          const stream = new CompressionStream('zstd');
          const w = stream.writable.getWriter();
          await w.write(data);
          await w.close();
          return new Uint8Array(await new Response(stream.readable).arrayBuffer());
        } else if (zstdWasm) {
          return zstdWasm.compress(data, 3);
        }
        throw new Error('No zstd compression available');
      }

      // Raw zstd decompress helper
      async function zstdDecompressRaw(data) {
        if (hasNativeZstd) {
          const stream = new DecompressionStream('zstd');
          const w = stream.writable.getWriter();
          await w.write(data);
          await w.close();
          return new Uint8Array(await new Response(stream.readable).arrayBuffer());
        } else if (zstdWasm) {
          return zstdWasm.decompress(data);
        }
        throw new Error('No zstd decompression available');
      }

      // Compress based on mode
      async function compress(data) {
        if (compressionMode === 'none' || compressionMode === 'deflate') {
          return data;
        }
        if (compressionMode === 'smaz') {
          return smazCompress(data);
        }
        // zstd
        return zstdCompressRaw(data);
      }

      // Decompress based on mode (no padding - live streaming)
      async function decompressSimple(data) {
        if (compressionMode === 'none' || compressionMode === 'deflate') {
          return data;
        }
        if (compressionMode === 'smaz') {
          return smazDecompress(data);
        }
        // zstd
        return zstdDecompressRaw(data);
      }

      // Decompress - same for snapshot and live streaming now
      async function decompress(data) {
        return decompressSimple(data);
      }

      function updateCodecDisplay() {
        const el = document.getElementById('s-codec');
        if (compressionMode === 'none') {
          el.textContent = 'none';
        } else if (compressionMode === 'deflate') {
          el.textContent = 'deflate';
        } else if (compressionMode === 'smaz') {
          el.textContent = 'smaz';
        } else if (hasNativeZstd) {
          el.textContent = 'zstd/native';
        } else if (zstdWasm) {
          el.textContent = 'zstd/wasm';
        } else {
          el.textContent = 'loading...';
        }
      }
      
      updateCodecDisplay();

      // === Stats Tracking ===
      const stats = {
        totalIn: 0, totalOut: 0, framesIn: 0, framesOut: 0,
        samples: []
      };

      function recordIn(bytes) {
        stats.totalIn += bytes;
        stats.framesIn++;
        stats.samples.push({ ts: Date.now(), i: bytes, o: 0, fi: 1, fo: 0 });
      }

      function recordOut(bytes) {
        stats.totalOut += bytes;
        stats.framesOut++;
        stats.samples.push({ ts: Date.now(), i: 0, o: bytes, fi: 0, fo: 1 });
      }

      function formatB(b) {
        if (b < 1024) return b.toFixed(0) + 'B';
        if (b < 1048576) return (b / 1024).toFixed(1) + 'KB';
        return (b / 1048576).toFixed(2) + 'MB';
      }

      // Update stats display every second
      setInterval(() => {
        const now = Date.now();
        stats.samples = stats.samples.filter(s => s.ts > now - 5000);
        const i5 = stats.samples.reduce((a, s) => a + s.i, 0);
        const o5 = stats.samples.reduce((a, s) => a + s.o, 0);
        const fi5 = stats.samples.reduce((a, s) => a + s.fi, 0);
        const fo5 = stats.samples.reduce((a, s) => a + s.fo, 0);
        const ratio = i5 > 0 ? (o5 / i5 * 100).toFixed(1) + '%' : '-';
        const avg = stats.totalIn > 0 ? (stats.totalOut / stats.totalIn * 100).toFixed(1) + '%' : '-';
        
        document.getElementById('s-in').textContent = formatB(i5 / 5) + '/s';
        document.getElementById('s-out').textContent = formatB(o5 / 5) + '/s';
        document.getElementById('s-fps').textContent = (fi5 / 5).toFixed(1) + '/' + (fo5 / 5).toFixed(1);
        document.getElementById('s-ratio').textContent = ratio;
        document.getElementById('s-avg').textContent = avg;
        document.getElementById('s-total').textContent = formatB(stats.totalIn) + ' / ' + formatB(stats.totalOut);
      }, 1000);

      // === Terminal Setup ===
      const term = new Terminal({
        allowProposedApi: true,
      });
      const fitAddon = new FitAddon.FitAddon();
      term.loadAddon(fitAddon);
      term.open(document.getElementById('terminal'));
      
      // Track if runner has sent initial size
      let runnerControlsSize = false;
      
      // Initially fit to container, but runner resize messages take priority
      fitAddon.fit();
      window.addEventListener('resize', () => {
        if (!runnerControlsSize) fitAddon.fit();
      });
      
      // === WebSocket Setup ===
      const protocol = location.protocol === 'https:' ? 'wss:' : 'ws:';
      const ws = new WebSocket(protocol + '//' + location.host + '/ws?id=' + sessionId + '&token=' + token);
      ws.binaryType = 'arraybuffer';
      
      ws.onopen = () => console.log('ws connected');
      
      ws.onmessage = async (e) => {
        if (typeof e.data === 'string') {
          try {
            const msg = JSON.parse(e.data);
            if (msg.type === 'compression' && msg.mode) {
              compressionMode = msg.mode;
              // Load zstd wasm if needed
              if (compressionMode === 'zstd' && !hasNativeZstd) {
                await loadZstdWasm();
              }
              updateCodecDisplay();
            }
            if (msg.type === 'ready') {
              // Snapshot received, ready for live streaming
            }
            if (msg.type === 'exit') term.write('\r\n[Process exited with code ' + msg.code + ']');
            if (msg.type === 'resize' && msg.cols && msg.rows) {
              runnerControlsSize = true;
              term.resize(msg.cols, msg.rows);
              // Fix auto-scroll issue: ensure viewport scrolls to bottom after resize
              term.scrollToBottom();
            }
          } catch { term.write(e.data); }
        } else {
          // Binary data - terminal output
          const buf = new Uint8Array(e.data);
          recordIn(buf.byteLength);
          try {
            const dec = await decompress(buf);
            term.write(dec);
          } catch (err) {
            console.error('Decompression error:', err);
          }
        }
      };
      
      ws.onclose = (e) => {
        console.log('ws closed', e.code, e.reason);
        term.write('\r\n[Connection closed: ' + (e.reason || e.code) + ']');
      };
      
      // === Input Handling ===
      // Handle keyboard input
      term.onData(async (data) => {
        if (ws.readyState === 1) {
          try {
            const compressed = await compress(new TextEncoder().encode(data));
            recordOut(compressed.byteLength);
            ws.send(compressed);
          } catch (err) {
            console.error('Compression error:', err);
          }
        }
      });
      
      // Handle binary data (mouse events in SGR mode send binary)
      term.onBinary(async (data) => {
        if (ws.readyState === 1) {
          try {
            // Convert binary string to Uint8Array
            const bytes = new Uint8Array(data.length);
            for (let i = 0; i < data.length; i++) {
              bytes[i] = data.charCodeAt(i);
            }
            const compressed = await compress(bytes);
            recordOut(compressed.byteLength);
            ws.send(compressed);
          } catch (err) {
            console.error('Compression error:', err);
          }
        }
      });
      
      // Button handlers
      window.send = async (text) => {
        if (ws.readyState === 1) {
          try {
            const compressed = await compress(new TextEncoder().encode(text));
            recordOut(compressed.byteLength);
            ws.send(compressed);
          } catch (err) {
            console.error('Compression error:', err);
          }
        }
      };
      
      window.sendLine = async (text) => {
        if (ws.readyState === 1) {
          try {
            const compressed = await compress(new TextEncoder().encode(text + '\r'));
            recordOut(compressed.byteLength);
            ws.send(compressed);
          } catch (err) {
            console.error('Compression error:', err);
          }
        }
      };
    }
  </script>
</body>
</html>
